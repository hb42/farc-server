/**
 * Created by hb on 02.06.16.
 */

import * as fs from "fs";
import { fs as pfs } from "mz";
import * as path from "path";
import * as R from "ramda";

import {
    FarcDriveDocument,
    FarcEndpunktDocument,
    FarcEntryDocument,
    FarcTreeDocument,
    FarcTreeNode,
} from "../common/farc/model";
import {
  farcDriveModel,
  farcEndpunktModel,
  farcEntryModel,
  farcTreeModel,
} from "../model";

export class FarcReadDir {

  private tree: FarcTreeNode[];
  private startRead: number;  // DEBUG

  constructor() {
    // TODO nur fuer Tests auskommentiert (und bis readdir aufgeteilt)
    // this.makeTrees().then(tree => {
    //   this.tree = tree;
    // });
  }

  // TODO drive new/change/del
  // TODO ep new/change/del -> class

  /* FIXME
     - treenode.type als enum
     - evtl. populate rausnehmen
     - zusaetzliche Datentypen f. View?
     - selected-Feld f. treenode -> Pflege?
     - back pointer in farc_tree kann raus
     - zwei classes f. (1) Einlesen, evtl. select und (2) tree handling f. View

     TEST: 1. timing fuer Einlesen als blob
   found 4 EPs
   node: ng2test2
   node: ng2-book
   node: ng2test2
   node: ng2-book
   could not read /Users/hb/tmp/Workspaces/JavaScript/ng2test2
   could not read /Users/hb/tmp/Workspaces/JavaScript/ng2-book
   milis reading=696
   milis adding=703
   milis reading=792
   milis adding=795
   milis saving=1464
   milis saving=1804

           2. save rec je dir/file -> timing?
              TODO document/model bauen
   ITEMSs removed
   found 4 EPs
   node: ng2test2
   node: ng2-book
   node: ng2test2
   could not read /Users/hb/tmp/Workspaces/JavaScript/ng2test2
   node: ng2-book
   could not read /Users/hb/tmp/Workspaces/JavaScript/ng2-book
   milis reading=28686
   milis reading=28995
   => ~16-fach langsamer
           mit Promises und Berechnung der treesize
   ITEMSs removed
   found 4 EPs
   node: ng2test2
   node: ng2-book
   node: ng2-book
   node: ng2test2
   error Error: ENOENT: no such file or directory, scandir '/Users/hb/tmp/Workspaces/JavaScript/ng2-book'
   sum 0
   milis reading=18
   error Error: ENOENT: no such file or directory, scandir '/Users/hb/tmp/Workspaces/JavaScript/ng2test2'
   sum 0
   milis reading=53
   sum 38170078
   milis reading=31889
   sum 155900283
   milis reading=32107
     => ~18x

           3. lazy loading im tree
   */

  /*
   * Unterverzeichnisebene unter path holen.
   */
  // FIXME verwendet: FarcTreeNode type, data (aendern!)/ FarcTreeDocument tree/ FarcEndpunktDocument roles
  public getSubdirsFor(path: string[], userroles: string[]): Promise<FarcTreeNode>[] {
    let nodes: FarcTreeNode[] = this.findSubdirs(this.tree, path);
    return nodes.map( (n: FarcTreeNode, idx: number) => {
      // FIXME
      if (n.type === "e" && n.data.tree) {  // FIXME EP nicht in .data
        // EP aus der DB holen und in this.tree eintragen
        // TODO Benutzer-Rechte pruefen -> n.data.roles <-> userroles (evtl. in extra Obj. auslagern)
        return farcTreeModel.findById(n.data.tree).exec().then( (tree: FarcTreeDocument) => {
          nodes[idx] = tree.tree;
          // FIXME data format/ transform
          return {
            label    : tree.tree.label,
            leaf     : tree.tree.children.length > 0 ? false : true,  // w/lazy loading
            timestamp: tree.tree.timestamp,
            size     : tree.tree.size,
            treesize : tree.tree.treesize,
            files    : tree.tree.files,
            type     : tree.tree.type,
            arc      : tree.tree.arc,
            path     : n.path,
          };
        });
      } else {
        // vorhandenes dir liefern
        // TODO Benutzer-Rechte pruefen -> n.data.roles <-> userroles (evtl. in extra Obj. auslagern)
        return new Promise( (resolve, reject) => {
          // FIXME data format/ transform
          resolve( {
            label    : n.label,
            leaf     : n.children.length > 0 ? false : true,  // w/lazy loading
            timestamp: n.timestamp,
            size     : n.size,
            treesize : n.treesize,
            files    : n.files,
            type     : n.type,
            arc      : n.arc,
            path     : n.path,
          } );
        });
      }
    });
  }

  // FIXME verwendet farcTreeModel, farcEndpunktModel/ populate(drive)
  public read() {
    farcTreeModel.find(err => { ; }).remove(err => {
      if (err) {
        console.error("error removing TREEs");
      } else {
        console.info("TREEs removed");
        farcEndpunktModel.find({}, err2 => { ; })
                     .populate("drive")
                     .exec((err3: Error, result: FarcEndpunktDocument[]) => {
              if (err3) {
                console.error("db error " + err3);
              } else {
                // console.info(result);
                console.info("found " + result.length + " EPs");
                result.forEach(ep => {
                  this.readEp(ep);
                });
              }
            });
      }
    });

  }

  // ############
  // XXX fuer Item async
  public read2() {
    farcEntryModel.find(err => { ; }).remove(err => {
      if (err) {
        console.error("error removing ITEMSs");
      } else {
        console.info("ITEMSs removed");
        farcEndpunktModel.find({}, err2 => { ; })
                     .populate("drive")
                     .exec((err3: Error, result: FarcEndpunktDocument[]) => {
              if (err3) {
                console.error("db error " + err3);
              } else {
                // console.info(result);
                console.info("found " + result.length + " EPs");
                result.forEach(ep => {
                  this.readEp2(ep);
                });
              }
            });
      }
    });

  }

  // ############
  // XXX Test Einlesen
  public getDirs() {
    this.startRead = Date.now();
    farcEndpunktModel.find({}, err2 => { ; })
                     .populate("drive")
                     .exec((err3: Error, result: FarcEndpunktDocument[]) => {
                       if (err3) {
                         console.error("db error " + err3);
                       } else {
                         // console.info(result);
                         console.info("found " + result.length + " EPs");
                         result.forEach(ep => {
                           this.getdirentries(ep._id);
                         });
                       }
                     });
  }
  // #########
  public getdirentries(id) {
    farcEntryModel.find({parent: id}).exec().then( (res: FarcEntryDocument[]) => {
      res.forEach((item: FarcEntryDocument) => {
        if (item.type !== "F") {
          console.info((Date.now() - this.startRead) + "  " + item.type + " " + item.leaf + " "
                     + item.label + " (" + item.path.join("/") + ")");
          this.getdirentries(item._id);
        }
      });
    });
  }

  // funktioniert immer
  // drvschema = (select) => this.model.DRIVE.find(select);
  //
  // funktioniert nur, mit R.bind(fn, this)
  // drvschema (select) {
  //   return this.model.DRIVE.find(select);
  // }
  // FIXME verwendet farcDriveModel
  public makeTrees(): Promise<FarcTreeNode[]> {

    // let self = this;
    let drives = (select) => farcDriveModel.find(select);
    let buildTrees = (drvs) => Promise.all( drvs.map((drv: FarcDriveDocument) => this.makeDriveTree(drv)) );

    let gettree = R.bind( R.pipeP(drives, buildTrees), this ); // IDE zeigt Fehler, typings nicht aktuell/fehlerhaft
    // gettree({}).then( tree => {console.info("testR.then");console.dir(tree);});
    return gettree({});
  }

  /**
   * Endpunkte fuer ein Laufwerk aus DB holen und zusammensetzen
   *
   * TODO source + archive muessen getrennt verarbeitet werden
   * @returns {FarcTreeNode}
   */
  // FIXME verwendet: FarcTreeNode children, label
  public makeDriveTree(drive: FarcDriveDocument): Promise<FarcTreeNode> {

    // FIXME data format/ transform
    let driveroot: FarcTreeNode = {
      // label     : drive.sourcepath,
      label     : drive.displayname,
      timestamp: null,
      size     : 0,
      children : <FarcTreeNode[]> [],
      files    : null,
      type     : "S",
      arc      : drive.arc,
      path     : [drive.displayname],
    };

    return farcEndpunktModel.find({drive: drive.id}, err => { ; })/*.populate("tree")*/.exec().then((result) => {
        result.forEach( (ep: FarcEndpunktDocument) => {
          let node: FarcTreeNode = driveroot;
          // Pfad ab drive zum EP aufbauen
          ep.above.forEach(dir => {
            let ch: FarcTreeNode[] = node.children.filter( n => dir === n.label );
            if (ch && ch.length === 1) {
              node = ch[0];
            } else {
              // FIXME data format/ transform
              let child: FarcTreeNode = {
                label     : dir,
                timestamp: null,
                size     : 0,
                children : <FarcTreeNode[]> [],
                files    : null,
                type     : "S",
                arc      : drive.arc,
                path     : node.path.concat(dir),
              };
              node.children.push(child);
              node = child;
            }
          });
          // statt EP Platzhalter einfuegen, der erst beim Zugriff aufgeloest wird
          // FIXME data format/ transform
          let epnode: FarcTreeNode = {
            label:     ep.endpunkt,
            timestamp: null,
            size:      ep.size,
            children:  <FarcTreeNode[]> [],
            files:     null,
            type:      "e",   // EP-Knoten, der noch zu fuellen ist
            arc:       drive.arc,
            path:      node.path.concat(ep.endpunkt),
            data:      ep,  // FIXME EP-Record fuers spaetere Einlesen -> nicht data verwenden
          };
          node.children.push(epnode);

          // if (ep.tree) {
          //   ep.tree["tree"].type = "E";  // ep.tree wird durch populate() aufgeloest
          //   node.children.push(ep.tree["tree"]);
          // }
        });
        return driveroot;
    });
  }

  /*
   * Unterverzeichnisebene unter path holen.
   * Wenn path === [] || undefined wird die oberste Ebene geliefert
   */
  // FIXME verwendet FarcTreeNode label, children
  private findSubdirs(tree: FarcTreeNode[], path: string[]): FarcTreeNode[] {
    if (!path) {
      return tree;
    }
    path.forEach(p => {
      if (tree) {
        let res: FarcTreeNode = tree.reduce((n1, n2) => n2.label === p ? n2 : n1, null);
        tree = res ? res.children : null;
      }
    });
    return tree;
  }

  /**
   * Verzeichnis rekursiv einlesen
   *
   * @param dir - Pfad
   * @param parent - Verzeichnisknoten
   * @oaram arc - Archive?
   * @param done - callback
   */
  // FIXME verwendet: FarcTreeNode children, files, size
  private walk(dir: string, parent: FarcTreeNode, archive: boolean, done) {
    fs.readdir(dir, (err, list) => {
      if (err) { return done(err); }
      list.sort();
      let pending = list.length;
      if (!pending) { return done(null); }  // save parent
      list.forEach(filename => {
        let file = path.resolve(dir, filename);
        fs.stat(file, (error, stat) => {
          if (stat) {
            let node: FarcTreeNode;
            if (stat.isDirectory()) {
              // FIXME data format/ transform
              node = {
                // parent: parent._id
                label     : filename,
                timestamp: stat.mtime,  // atime, etc. auch speichern?
                size     : 0,
                children : <FarcTreeNode[]> [],
                files : <FarcTreeNode[]> [],
                type : "D",
                arc : archive,
                path : parent.path.concat(filename),
              };
              parent.children.push(node);
              this.walk(file, node, archive, (walkerr) => {
                pending--;
                if (!pending) { done(null); } // save node
              });
            } else {
              // FIXME data format/ transform
              node = {
                label     : filename,
                timestamp: stat.mtime,
                size     : stat.size,
                type     : "F",
                arc      : archive,
                path     : [],
              };
              parent.files.push(node);
              parent.size += node.size;
              pending--;
              if (!pending) { done(null); } // save parent
            }
          } else {
            console.error("stat error: " + error);
          }
        });
      });
      // save parent -> nur wenn Sync
    });
  }

  /*
  readdir.then list => {
    promise[]
    list.foreach filename => {
      stat.then stat => {
        isDir ?
          promise.push
          save(newDir).then err => {
            return recurse
          }
        :
          promise.push
          save(newFile).then err => {
            return size+
          }
      }
    }
    return promise[]
  }.then promise[] => {
    Promise.all(promise[]).then num[] => {
      sum = num reduce a,b => a+b
      parent.size = sum
      parent.save
      return sum
    }
  }

   */
  // ###########
  // XXX fuer Item async
  private walk2(dir: string, parent: FarcEntryDocument, archive: boolean): Promise<number> {
    let leaf: boolean = true;
    // dir async lesen
    return pfs.readdir(dir).then( (list) => {
      // promises fuer die Dir-Eintraege sammeln
      let saves: Promise<number>[] = [];
      list.forEach(filename => {
        let entry = path.resolve(dir, filename);
        // Verzeichniseintrag holen (async) und das Promise merken
        let save: Promise<number> = pfs.stat(entry).then( (stat) => {
          if (stat.isDirectory()) {
            leaf = false;
            // FIXME data format/ transform
            let directory = new farcEntryModel({
              parent   : parent._id,
              label    : filename,
              timestamp: stat.mtime,  // atime, etc. auch speichern?
              size     : 0,
              // children : <FarcTreeNode[]> [],
              // files : <FarcTreeNode[]> [],
              type     : "D",
              arc      : archive,
              path     : parent.path.concat(filename),
              leaf     : true,
              selected : false,
            });
            // Eintrag speichern, Rekursion braucht directory._id
            return directory.save().then(e1 => {
              // Rekursion liefert Promise mit tree size
              return this.walk2(entry, directory, archive);
            });
          } else {
            // FIXME data format/ transform
            let file = new farcEntryModel({
              parent   : parent._id,
              label    : filename,
              timestamp: stat.mtime,
              size     : stat.size,
              type     : "F",
              arc      : archive,
              path     : parent.path,
              selected : false,
            });
            // Datei-Eintrag speichern und file size im Promise zurueckgeben
            return file.save().then( e2 => stat.size );
          }
        });
        saves.push(save);
      });
      return saves;
    }).then( (p: Promise<number>[]) => {
      // hier kommen die Promises fuer die Verzeichnisebene rein
      return Promise.all(p).then( (num: number[]) => {
        // alle Promises aufloesen, Summe errechnen und im parent speichern
        let sum: number = num.reduce( (a, b) => a + b, 0);
        parent.size = sum;
        parent.leaf = leaf;
        parent.save();
        return sum;
      });
    }).catch( err => {
      // i.d.R. ENOENT
      console.info("error " + err);
      return 0;
    });
  }

  /**
   * Treesize der Knoten berechnen
   *
   * @param tree - Verzeichnis
   */
  // FIXME verwendet: FarcTreeNode treesize, size, children
  private makeSum(tree: FarcTreeNode): void {
    let recur = (nodes: FarcTreeNode[]): number => {
      // nodes.sort((a,b) => a.name.localeCompare(b.name) );
      let sum: number = 0;
      nodes.forEach(node => {
        // node.files.sort((a,b) => a.name.localeCompare(b.name) );
        node.treesize = node.size + recur(node.children);
        sum += node.treesize;
      });
      return sum;
    };
    // tree.files.sort((a,b) => a.name.localeCompare(b.name) );
    tree.treesize = recur(tree.children);
  }

  /**
   * Baum fuer Endpunkt einlesen und speichern
   *
   * // TODO drive handling/ source- + archivepath
   * @param endpunkt
   */
  // FIXME verwendet: FarcEndpunktDocument drive (populate!), above, endpunkt, size, tree/ FarcDrive arc, sourcepath
  // FIXME            FarcTreeNode treesize
  private readEp(endpunkt: FarcEndpunktDocument) {
    let startread = Date.now();  // DEBUG
    /* type error, weil mongoose die Referenz aufloest */
    let drive: FarcDriveDocument = <FarcDriveDocument> endpunkt["drive"]; // .sourcepath;
    let archive: boolean = drive.arc;

    let epPath: string = [drive.sourcepath].concat(endpunkt.above).concat(endpunkt.endpunkt).join("/");

    // let rootpath: string[] = [drive.displayname].concat(endpunkt.above).concat(endpunkt.endpunkt);
    // Startknoten fuer den Baum
    // FIXME data format/ transform
    let root: FarcTreeNode = {
      label     : endpunkt.endpunkt,
      timestamp: null,
      size     : 0,
      children : <FarcTreeNode[]> [],
      files    : <FarcTreeNode[]> [],
      type     : "E",
      arc      : archive,
      path     : [drive.displayname].concat(endpunkt.above).concat(endpunkt.endpunkt),
    };
    // neues document f. tree data
    // (wenn hier schon root eingetragen wuerde, wuerde der Datensatz mit diesem Stand gespeichert,
    //  ohne die im Folgenden eingelesenen Daten)
    let tree = new farcTreeModel({endpunkt: endpunkt._id, tree: null});

    console.info("node: " + root.label); // DEBUG

    // Rekursion
    this.walk(epPath, root, archive, (err) => {
      if (err) {
        console.error("could not read " + epPath);
      } else {

        console.info("milis reading=" + (Date.now() - startread)); // DEBUG

        // startread = Date.now(); // DEBUG
        // Summen berechnen und eintragen, dann muss das zur Laufzeit nicht mehr berechnet werden
        this.makeSum(root);

        // tree data im Datensatz eintragen (erst eintragen, wenn der Baum aufgebaut ist)
        tree.tree = root;
        endpunkt.size = root.treesize;

        // tree data speichern
        tree.save(err2 => {
          if (err2) {
            console.error("db error " + err2);
          } else {
            // id im parent document eintragen
            endpunkt.tree = tree._id;
            endpunkt.save(err3 => {  // Fehler weil typings nicht aktuell
              if (err3) {
                console.error("db error " + err3);
              } else {
                console.info("milis saving=" + (Date.now() - startread)); // DEBUG
              }
            });
          }
        });
        console.info("milis adding=" + (Date.now() - startread)); // DEBUG

        // DEBUG
        // prt(root);
      }
    });

  }

  // ###########
  // XXX fuer Item async
  private readEp2(endpunkt: FarcEndpunktDocument) {
    let startread = Date.now();  // DEBUG
    /* type error, weil mongoose die Referenz aufloest */
    let drive: FarcDriveDocument = <FarcDriveDocument> endpunkt["drive"]; // .sourcepath;
    let archive: boolean = drive.arc;

    let epPath: string = [drive.sourcepath].concat(endpunkt.above).concat(endpunkt.endpunkt).join("/");

    // let rootpath: string[] = [drive.displayname].concat(endpunkt.above).concat(endpunkt.endpunkt);
    // Startknoten fuer den Baum
    // FIXME data format/ transform
    let root = new farcEntryModel({
      parent    : endpunkt._id,
      label     : endpunkt.endpunkt,
      timestamp: null,
      size     : 0,
      // children : <FarcTreeNode[]> [],
      // files    : <FarcTreeNode[]> [],
      type     : "E",
      arc      : archive,
      path     : [drive.displayname].concat(endpunkt.above).concat(endpunkt.endpunkt),
      leaf     : true,
      selected : false,
    });
    root.save().then( e1 => {
      console.info("node: " + root.label); // DEBUG

      // Rekursion
      this.walk2(epPath, root, archive).then( (sum) => {
        console.info("sum " + sum);
        console.info("milis reading=" + (Date.now() - startread)); // DEBUG
      });

    });
  }

}
